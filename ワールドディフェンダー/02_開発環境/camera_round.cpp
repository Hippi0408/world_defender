//=============================================================================
//
// camera_round.cpp
// Author : koduna hirohito
//
//=============================================================================

//*****************************************************************************
// インクルード
//*****************************************************************************
#include "camera_round.h"
#include "convenience_function.h"

const float CCamera_Round::DISTANCE = 7000.0f;
const float CCamera_Round::ROT_MOVE = D3DXToRadian(-0.25f);
//*****************************************************************************
// コンストラクタ
//*****************************************************************************
CCamera_Round::CCamera_Round()
{
	m_Rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_RotMove = D3DXVECTOR3(0.0f, ROT_MOVE,0.0f);
}

//*****************************************************************************
// デストラクタ
//*****************************************************************************
CCamera_Round::~CCamera_Round()
{
}

//*****************************************************************************
// 初期化
//*****************************************************************************
HRESULT CCamera_Round::Init()
{
	//親クラスのInit
	if (FAILED(CCamera::Init()))
	{
		return -1;
	}

	return S_OK;
}

//*****************************************************************************
// 更新処理
//*****************************************************************************
void CCamera_Round::Update()
{
	CCamera::Update();

	//視点
	D3DXVECTOR3 posV = GetPosV();

	//視点の変更
	posV.x = cosf(m_Rot.y) * DISTANCE;
	posV.z = sinf(m_Rot.y) * DISTANCE;
	posV.y = DISTANCE;

	//視点の保存
	SetPosV(posV);

	//向きの変更
	m_Rot += m_RotMove;

	//正規化
	m_Rot = CConvenience_Function::NormalizationRot(m_Rot);
}
